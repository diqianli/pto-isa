"""
PTO Code Generator for Ascend A2/A3 Cycle-Accurate Simulator

This module generates pure C code for cycle-accurate simulation of Ascend A2/A3 NPU.

Key Features:
- Generates standalone C code (no Ascend SDK dependency)
- Includes cycle cost functions for each instruction
- Supports dual-queue scheduling (vector/cube)
- Generates trace output for waveform analysis

Architecture Model:
- Vector Engine: handles element-wise ops, reductions, memory ops
- Cube Engine: handles matrix multiply operations
- Memory Hierarchy: GM (global) -> L1 (scratchpad) -> Register

Cycle Cost Model (approximate for Ascend 910B):
- TLOAD/TSTORE: ~100 cycles (GM access)
- Element-wise ops: ~10 cycles per tile
- Reductions: ~20 cycles per tile  
- MatMul: ~50 cycles per 32x32 tile
"""

import os
import sys
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass

# Add parent directories to path
_current_dir = os.path.dirname(os.path.abspath(__file__))
_src_dir = os.path.dirname(_current_dir)
if _src_dir not in sys.path:
    sys.path.insert(0, _src_dir)

from compile.pto_compile_common import (
    PTOProgram, PTOModule,
    MockInstruction, MockTileInfo, convert_program_to_mock_instructions,
    TileBufferAnalyzer,
)
from isa_definition.pto_isa_definition import (
    ElementType, MemorySpace,
    ARM64_TYPE_MAP,  # Reuse for C types
)

# =============================================================================
# Cycle Cost Model for Ascend A2/A3
# =============================================================================

# Cycle costs for different operations (approximate for 910B @ 1.8GHz)
ASCEND_A2A3_CYCLE_COSTS = {
    # Memory operations (GM access is expensive)
    "TLOAD": 100,
    "TSTORE": 100,
    
    # Element-wise operations (Vector Engine)
    "TADD": 8,
    "TSUB": 8,
    "TMUL": 8,
    "TDIV": 16,
    "TEXP": 24,
    "TLOG": 24,
    "TSQRT": 16,
    "TRSQRT": 16,
    "TSILU": 20,
    "TRELU": 8,
    "TTANH": 24,
    "TSIGMOID": 24,
    "TGELU": 28,
    "TABS": 4,
    "TNEG": 4,
    
    # Scalar-tile operations
    "TADDS": 8,
    "TSUBS": 8,
    "TMULS": 8,
    "TDIVS": 16,
    "TMAXS": 8,
    "TMINS": 8,
    
    # Reduction operations
    "TROWSUM": 20,
    "TROWMAX": 20,
    "TROWMIN": 20,
    "TCOLSUM": 20,
    "TCOLMAX": 20,
    "TCOLMIN": 20,
    
    # Broadcast operations
    "TROWEXPAND": 12,
    "TCOLEXPAND": 12,
    "TROWEXPANDADD": 16,
    "TROWEXPANDSUB": 16,
    "TROWEXPANDMUL": 16,
    "TROWEXPANDDIV": 20,
    
    # Matrix operations (Cube Engine)
    "TMATMUL": 50,      # Per 32x32 output tile
    "TMATMULACC": 50,
    
    # Comparison
    "TCMP": 8,
    "TCMPS": 8,
    "TSEL": 10,
    "TSELS": 10,
    
    # Data movement
    "TMOV": 4,
    "TCVT": 8,
    "TTRANS": 16,
    
    # Control flow (negligible)
    "FOR": 1,
    "ENDFOR": 1,
    "IF": 1,
    "ELSE": 1,
    "ENDIF": 1,
    "CALL": 2,
    "RETURN": 1,
    
    # Scalar operations
    "SLI": 1,
    "SADD": 1,
    "SSUB": 1,
    "SMUL": 1,
    "SDIV": 2,
    "SCMP": 1,
}

# Which operations go to Cube Engine vs Vector Engine
CUBE_OPS = {"TMATMUL", "TMATMULACC"}
VECTOR_OPS = set(ASCEND_A2A3_CYCLE_COSTS.keys()) - CUBE_OPS - {"FOR", "ENDFOR", "IF", "ELSE", "ENDIF", "CALL", "RETURN"}


def get_cycle_cost(opcode: str, rows: int = 32, cols: int = 128) -> int:
    """
    Get cycle cost for an operation.
    
    Scales based on tile size relative to base 32x128.
    """
    base_cost = ASCEND_A2A3_CYCLE_COSTS.get(opcode, 10)
    
    # Scale by tile size
    base_elements = 32 * 128
    actual_elements = rows * cols
    scale = max(1, actual_elements // base_elements)
    
    return base_cost * scale


def is_cube_op(opcode: str) -> bool:
    """Check if operation uses Cube Engine."""
    return opcode in CUBE_OPS


# =============================================================================
# C Code Generation for Simulator
# =============================================================================

def generate_sim_header() -> str:
    """Generate header for simulation code."""
    return '''// PTO Ascend A2/A3 Cycle-Accurate Simulator
// Auto-generated by PTO ISA Compiler

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

// Enable A2A3 platform for dual-queue simulation
#define PTO_PLATFORM_A2A3

// Include PTO runtime with simulation support
#include "pto_runtime.h"
#include "pto_runtime.c"

'''


def generate_cycle_cost_functions(tile_info: Dict[str, MockTileInfo]) -> str:
    """Generate cycle cost functions for InCore functions."""
    lines = []
    lines.append("// =============================================================================")
    lines.append("// Cycle Cost Functions for Ascend A2/A3 Simulation")
    lines.append("// =============================================================================")
    lines.append("")
    
    # Generate a generic cost function based on function name pattern
    lines.append("""
// Generic cycle cost based on function name pattern
int64_t estimate_cycle_cost(const char* func_name) {
    // MatMul operations (Cube Engine)
    if (strstr(func_name, "matmul") || strstr(func_name, "gemm")) {
        return 50;  // Base matmul cost
    }
    
    // Reduction operations
    if (strstr(func_name, "rowsum") || strstr(func_name, "rowmax") || 
        strstr(func_name, "colsum") || strstr(func_name, "colmax")) {
        return 20;
    }
    
    // Broadcast operations
    if (strstr(func_name, "expand") || strstr(func_name, "broadcast")) {
        return 16;
    }
    
    // Activation functions
    if (strstr(func_name, "silu") || strstr(func_name, "gelu") || 
        strstr(func_name, "relu") || strstr(func_name, "sigmoid")) {
        return 20;
    }
    
    // Softmax components
    if (strstr(func_name, "softmax") || strstr(func_name, "exp")) {
        return 24;
    }
    
    // Normalization
    if (strstr(func_name, "norm") || strstr(func_name, "rsqrt")) {
        return 30;
    }
    
    // RoPE (rotary position embedding)
    if (strstr(func_name, "rope")) {
        return 40;
    }
    
    // Attention components
    if (strstr(func_name, "attention") || strstr(func_name, "score")) {
        return 60;
    }
    
    // Default element-wise
    return 10;
}

// Cycle cost wrapper that scales by tile size
int64_t cycle_cost_wrapper(void** args, int32_t num_args) {
    // In simulation, we don't have access to actual args easily
    // Use a base cost that will be overridden per-task
    return 10;
}
""")
    
    return "\n".join(lines)


def generate_sim_main(orch_func_name: str, params: List[Tuple[str, str]]) -> str:
    """Generate main function for simulation."""
    # Build parameter declarations for test data
    param_decls = []
    param_args = []
    free_stmts = []
    
    # Track integer parameters that can be overridden via command line
    int_params = []
    int_param_idx = 0
    
    for ptype, pname in params:
        if '*' in ptype:
            # Pointer - allocate test data
            base_type = ptype.replace('*', '').strip()
            param_decls.append(f"    {base_type}* {pname} = ({base_type}*)calloc(1024 * 1024, sizeof({base_type}));")
            param_args.append(pname)
            free_stmts.append(f"    free({pname});")
        else:
            # Scalar - use default value or command line argument
            if 'int' in ptype:
                int_params.append((pname, int_param_idx))
                int_param_idx += 1
                param_decls.append(f"    {ptype} {pname} = 16;  // Default, override with argv[{int_param_idx}]")
            else:
                param_decls.append(f"    {ptype} {pname} = 1.0f;  // Default test value")
            param_args.append(pname)
    
    # Generate command line argument parsing for integer parameters
    argv_parsing = ""
    if int_params:
        argv_parsing = "\n    // Parse command line arguments for integer parameters\n"
        for pname, idx in int_params:
            argv_parsing += f"    if (argc > {idx + 1}) {pname} = atoi(argv[{idx + 1}]);\n"
    
    return f'''
// =============================================================================
// Main Function for Simulation
// =============================================================================
// Usage: {orch_func_name} [--benchmark-only] [seq_len] [tile_rows] [num_tiles] [zero]
// Flags:
//   --benchmark-only  - Only run orchestration (skip simulation), output stats
// Environment variables:
//   PTO_TRACE_OUTPUT=file - Output trace file path

int main(int argc, char** argv) {{
    // Check for --benchmark-only flag
    int benchmark_only = 0;
    int arg_offset = 0;
    
    for (int i = 1; i < argc; i++) {{
        if (strcmp(argv[i], "--benchmark-only") == 0) {{
            benchmark_only = 1;
            arg_offset = 1;
            break;
        }}
    }}
    
    if (!benchmark_only) {{
        printf("=== Ascend A2/A3 Cycle-Accurate Simulator ===\\n");
        printf("    Platform: Ascend 910B (A2/A3)\\n");
        printf("    Workers:  %d vector + %d cube\\n\\n", 
               A2A3_DEFAULT_VECTOR_WORKERS, A2A3_DEFAULT_CUBE_WORKERS);
    }}
    
    // Initialize runtime (heap allocated due to large size)
    PTORuntime* rt = (PTORuntime*)calloc(1, sizeof(PTORuntime));
    if (!rt) {{
        fprintf(stderr, "Failed to allocate runtime\\n");
        return 1;
    }}
    pto_runtime_init(rt);
    
    // Enable A2A3 simulation with platform-defined worker configuration
    // A2A3 (Ascend 910B): 48 vector workers + 24 cube workers
    pto_runtime_enable_a2a3_sim(rt, A2A3_DEFAULT_VECTOR_WORKERS, A2A3_DEFAULT_CUBE_WORKERS);
    
    // Note: pto_trace_init_dual is called inside pto_runtime_enable_a2a3_sim
    
    // Allocate test data
{chr(10).join(param_decls)}

    // Parse command line arguments for integer parameters (with offset for --benchmark-only flag)
    if (argc > 1 + arg_offset) seq_len = atoi(argv[1 + arg_offset]);
    if (argc > 2 + arg_offset) tile_rows = atoi(argv[2 + arg_offset]);
    if (argc > 3 + arg_offset) num_tiles = atoi(argv[3 + arg_offset]);
    if (argc > 4 + arg_offset) zero = atoi(argv[4 + arg_offset]);

    // Print configuration
    if (!benchmark_only) {{
        printf("Configuration:\\n");
        printf("  num_tiles = %d\\n", num_tiles);
        printf("\\nPhase 1: Building task graph...\\n");
    }}
    
    // === BENCHMARK: Measure orchestration time ===
    struct timespec start_time, end_time;
    clock_gettime(CLOCK_MONOTONIC, &start_time);
    
    // Call orchestration function to build task graph
    {orch_func_name}(rt, {", ".join(param_args)});
    
    clock_gettime(CLOCK_MONOTONIC, &end_time);
    double orch_time_ms = (end_time.tv_sec - start_time.tv_sec) * 1000.0 +
                          (end_time.tv_nsec - start_time.tv_nsec) / 1000000.0;
    // === END BENCHMARK ===
    
    int64_t tasks_submitted = rt->total_tasks_scheduled;
    
    if (benchmark_only) {{
        // Benchmark mode: just output stats in parseable format
        double tasks_per_ms = tasks_submitted / orch_time_ms;
        printf("BENCHMARK: num_tiles=%d tasks=%lld time_ms=%.3f tasks_per_ms=%.2f\\n",
               num_tiles, (long long)tasks_submitted, orch_time_ms, tasks_per_ms);
    }} else {{
        printf("  Submitted %lld tasks\\n", (long long)tasks_submitted);
        printf("  Orchestration time: %.3f ms (%.2f tasks/ms)\\n", 
               orch_time_ms, tasks_submitted / orch_time_ms);
        
        // Dump task graph before simulation
#ifdef PTO_TASK_DUMP
        pto_runtime_dump(rt, "{orch_func_name}_task_graph.txt");
#endif
        
        printf("\\nPhase 2: Running cycle-accurate simulation...\\n");
        
        // Run cycle-accurate simulation
        pto_simulate_all(rt);
        
        // Print cycle trace summary
        pto_trace_print_summary();
        
        // Save trace to JSON for visualization
        const char* trace_file = getenv("PTO_TRACE_OUTPUT");
        if (!trace_file) {{
            trace_file = "trace.json";
        }}
        pto_trace_write_json(trace_file);
        printf("Trace saved to: %s\\n", trace_file);
        printf("  Open in Chrome: chrome://tracing and load the file\\n");
    }}
    
    // Shutdown and free runtime
    pto_runtime_shutdown(rt);
    free(rt);
    
    // Free test data
{chr(10).join(free_stmts)}
    
    if (!benchmark_only) {{
        printf("\\n=== Simulation Complete ===\\n");
    }}
    return 0;
}}
'''


# =============================================================================
# Code Generator Class
# =============================================================================

class AscendA2A3SimCodeGenerator:
    """
    Code generator for Ascend A2/A3 cycle-accurate simulator.
    
    Generates pure C code with:
    - Cycle cost functions for timing simulation
    - Task graph construction using PTO runtime
    - Trace output for waveform analysis
    """
    
    def __init__(self, enable_fusion: bool = True, analyze_buffers: bool = True,
                 module: Optional[PTOModule] = None):
        self.enable_fusion = enable_fusion
        self.analyze_buffers = analyze_buffers
        self.module = module
    
    def generate(self, program: PTOProgram) -> str:
        """Generate simulation code for a program."""
        tile_info, mock_instructions = convert_program_to_mock_instructions(program)
        
        lines = []
        
        # Check if this is an orchestration function (not InCore)
        is_orchestration = not getattr(program, 'is_in_core', True)
        
        if is_orchestration:
            # Full simulation code with main() for orchestration functions
            lines.append(generate_sim_header())
            lines.append(generate_cycle_cost_functions(tile_info))
            lines.append("")
            lines.append(self._generate_orchestration(program, mock_instructions, tile_info))
            
            # Generate main for standalone execution
            params = self._extract_params(program)
            lines.append(generate_sim_main(program.name, params))
        else:
            # For InCore functions, generate a simple placeholder
            # (actual simulation is done via task scheduling)
            lines.append(f"// InCore function: {program.name}")
            lines.append(f"// This function is simulated via task scheduling")
            lines.append(f"// Estimated cycle cost: {get_cycle_cost(program.name.upper())}")
            lines.append("")
            lines.append("// Placeholder - InCore functions are executed as tasks")
            lines.append(f"// with cycle costs estimated by the simulator.")
        
        return "\n".join(lines)
    
    def _extract_params(self, program: PTOProgram) -> List[Tuple[str, str]]:
        """Extract function parameters."""
        params = []
        
        # Memory references become pointers
        for name, memref_type in program.memref_declarations.items():
            c_type = ARM64_TYPE_MAP.get(memref_type.element_type.value, "float")
            params.append((f"{c_type}*", name))
        
        # Scalars (except internally initialized ones)
        for name, scalar_type in program.scalar_declarations.items():
            if scalar_type in (ElementType.U1, ElementType.INDEX):
                continue
            c_type = ARM64_TYPE_MAP.get(scalar_type.value, "int32_t")
            params.append((c_type, name))
        
        return params
    
    def _generate_orchestration(self, program: PTOProgram, 
                                 mock_instructions: List[MockInstruction],
                                 tile_info: Dict[str, MockTileInfo]) -> str:
        """Generate orchestration function code."""
        lines = []
        
        lines.append(f"// Orchestration Function: {program.name}")
        lines.append(f"// Generates task graph for Ascend A2/A3 simulation")
        lines.append("")
        
        # Function signature
        params = self._extract_params(program)
        param_str = ", ".join(f"{t} {n}" for t, n in params)
        lines.append(f"void {program.name}(PTORuntime* rt, {param_str}) {{")
        lines.append("")
        
        # Task counter
        lines.append("    int32_t _task_id = 0;")
        lines.append("")
        
        # Generate code for each instruction
        indent = "    "
        task_counter = 0
        
        for instr in mock_instructions:
            opcode = instr.opcode
            
            if opcode == "TLOAD" or opcode == "TSTORE":
                # Memory ops - just track dependencies
                pass
            
            elif opcode == "CALL":
                # Generate task submission
                func_name = instr.dst
                is_cube = is_cube_op(func_name.upper()) or "matmul" in func_name.lower()
                cycle_cost = get_cycle_cost(func_name.upper()) if func_name.upper() in ASCEND_A2A3_CYCLE_COSTS else 10
                
                lines.append(f"{indent}// Task: {func_name} ({'Cube' if is_cube else 'Vector'} Engine)")
                lines.append(f"{indent}{{")
                lines.append(f"{indent}    int32_t t = pto_task_alloc(rt, \"{func_name}\", NULL, 0, 0, {'true' if is_cube else 'false'});")
                
                # Add inputs/outputs from args
                if isinstance(instr.operands, dict):
                    for arg_name, arg_info in instr.operands.items():
                        if isinstance(arg_info, tuple) and len(arg_info) >= 3:
                            tensor, row_idx, col_idx = arg_info[0], arg_info[1], arg_info[2]
                            rows = arg_info[3] if len(arg_info) > 3 else 32
                            cols = arg_info[4] if len(arg_info) > 4 else 128
                            if 'out' in arg_name.lower() or 'dst' in arg_name.lower():
                                lines.append(f"{indent}    pto_task_add_output(rt, t, {tensor}, {row_idx}, {col_idx}, {rows}, {cols});")
                            else:
                                lines.append(f"{indent}    pto_task_add_input(rt, t, {tensor}, {row_idx}, {col_idx}, {rows}, {cols});")
                
                # Set cycle cost function
                lines.append(f"{indent}    // Estimated {cycle_cost} cycles ({'Cube' if is_cube else 'Vector'} Engine)")
                lines.append(f"{indent}    pto_task_submit(rt, t);")
                lines.append(f"{indent}}}")
                lines.append("")
                task_counter += 1
            
            elif opcode == "FOR":
                iv = instr.dst
                lb = instr.operands[0] if instr.operands else "0"
                ub = instr.operands[1] if len(instr.operands) > 1 else "1"
                step = instr.operands[2] if len(instr.operands) > 2 else "1"
                lines.append(f"{indent}for (int {iv} = {lb}; {iv} < {ub}; {iv} += {step}) {{")
                indent += "    "
            
            elif opcode == "ENDFOR":
                indent = indent[:-4]
                lines.append(f"{indent}}}")
            
            elif opcode == "IF":
                cond = instr.operands[0] if instr.operands else "true"
                lines.append(f"{indent}if ({cond}) {{")
                indent += "    "
            
            elif opcode == "ELSE":
                indent = indent[:-4]
                lines.append(f"{indent}}} else {{")
                indent += "    "
            
            elif opcode == "ENDIF":
                indent = indent[:-4]
                lines.append(f"{indent}}}")
            
            elif opcode == "SLI":
                # Scalar load immediate
                dst = instr.dst
                val = instr.operands[0] if instr.operands else "0"
                lines.append(f"{indent}// SLI: {dst} = {val}")
        
        lines.append("}")
        
        return "\n".join(lines)


# =============================================================================
# Convenience Functions
# =============================================================================

def generate_ascend_a2a3_sim_code(program: PTOProgram, 
                                   enable_fusion: bool = True,
                                   module: Optional[PTOModule] = None) -> str:
    """Generate Ascend A2/A3 simulation code."""
    gen = AscendA2A3SimCodeGenerator(
        enable_fusion=enable_fusion,
        module=module
    )
    return gen.generate(program)


# =============================================================================
# Export
# =============================================================================

__all__ = [
    'AscendA2A3SimCodeGenerator',
    'generate_ascend_a2a3_sim_code',
    'ASCEND_A2A3_CYCLE_COSTS',
    'get_cycle_cost',
    'is_cube_op',
    'CUBE_OPS',
    'VECTOR_OPS',
]
