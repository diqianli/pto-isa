# PTO-ISA 两阶段依赖解析优化 - 实施指南

## 幻灯片 1: 集成概览

### 修改文件清单

```
PTO-ISA 代码库结构:
E:\cccode\pto-isa\
├── ref_runtime/
│   ├── include/pto/
│   │   └── pto_runtime2_types.h      ★ 修改1：新增优化结构
│   └── ...
│   └── src/runtime/rt2/
│       ├── runtime/
│       │   ├── pto_scheduler.h           ★ 修改2：扩展调度器状态
│       │   ├── pto_scheduler.c           ★ 修改3：核心两阶段逻辑
│       │   ├── pto_orchestrator.c       修改4：依赖链构建兼容性
│       └── ...
├── examples/
│   └── bgemm/
│       └── ...                     (无需修改)
└── CMakeLists.txt                     ★ 修改5：编译选项
```

### 集成时间表

| 阶段 | 文件修改 | 测试 | 时间 |
|------|---------|------|------|
| **Week 1** | 数据结构定义 | 编译验证 | 3-5天 |
| **Week 2-3** | 核心算法实现 | 单元测试 | 10-14天 |
| **Week 4-6** | 性能优化 | 集成测试 | 10-14天 |
| **Week 7-8** | 稳定性测试 | 文档编写 | 10-14天 |

---

## 幻灯片 2: 数据结构集成

### 修改1: pto_runtime2_types.h

**位置**: `ref_runtime/include/pto/pto_runtime2_types.h`

**修改内容**:

```c
// 在文件末尾添加

// ============================================================================
// 两阶段依赖解析优化数据结构
// ============================================================================

/**
 * 依赖解析状态枚举
 */
typedef enum {
    PTO2_DEP_STATE_UNKNOWN = 0,     // 初始状态
    PTO2_DEP_STATE_RESOLVING = 1,   // 正在解析（多依赖不确定）
    PTO2_DEP_STATE_LAST_ONE = 2,    // 只剩1个依赖，移到待定队列
    PTO2_DEP_STATE_READY = 3,       // 所有依赖满足，等待final_producer
    PTO2_DEP_STATE_PROCESSING = 4   // 正在处理ready转换
} PTO2DepResolutionState;

/**
 * 优化的任务描述符（缓存行对齐）
 */
typedef struct {
    // === 现有PTO2TaskDescriptor字段 ===
    int32_t task_id;
    int32_t kernel_id;
    int32_t worker_type;
    int32_t scope_depth;

    int32_t fanin_head;
    int32_t fanin_count;

    volatile int32_t fanout_lock;
    volatile int32_t fanout_head;
    volatile int32_t fanout_count;

    void* packed_buffer_base;
    void* packed_buffer_end;
    int32_t output_offsets[16];
    int32_t num_outputs;

    int32_t num_inputs;
    void* func_ptr;
    const char* func_name;
    bool is_active;

    // === 新增优化字段 ===
    PTO2DepResolutionState dep_state;        // 依赖解析状态 (1字节)
    int32_t final_producer_id;             // 最后一个生产者ID (4字节)
    int32_t fanin_refcount_fast;          // 快速路径计数 (4字节)
    int32_t ready_timestamp;               // ready时间戳 (4字节)

    // === 缓存行对齐 ===
    // 总大小确保是64字节的倍数
    char _padding[64 - (
        sizeof(int32_t) * 7 +  // 现有7个int32字段
        sizeof(PTO2DepResolutionState) +
        sizeof(int32_t) * 2 +  // 新增2个int32字段
        sizeof(int32_t)  // ready_timestamp
    )];

} __attribute__((aligned(64))) PTO2TaskDescriptorOptimized;

// 编译时开关
#ifdef PTO2_ENABLE_TWO_PHASE_OPT
    typedef PTO2TaskDescriptorOptimized PTO2TaskDescriptor;
    #define PTO2_TASK_DESCR_OPT_VERSION "2.0"
#else
    typedef PTO2TaskDescriptor PTO2TaskDescriptor;
    #define PTO2_TASK_DESCR_OPT_VERSION "1.0"
#endif
```

**集成检查点**:
- [ ] 枚举定义在现有枚举之后
- [ ] 结构体定义在文件末尾
- [ ] 正确使用 `#ifdef` 宏
- [ ] 缓存行对齐声明正确
- [ ] 向后兼容所有现用字段

### 修改2: pto_scheduler.h

**位置**: `ref_runtime/src/runtime/rt2/runtime/pto_scheduler.h`

**修改内容**:

```c
// 在文件末尾添加

// ============================================================================
// 两阶段依赖解析优化扩展
// ============================================================================

/**
 * 待定队列数据结构
 */
#define PENDING_QUEUE_CAPACITY 256

typedef struct {
    int32_t task_ids[PENDING_QUEUE_CAPACITY];
    volatile int64_t head;
    volatile int64_t tail;
    int32_t count;
    int32_t capacity;
    PTO2WorkerType worker_type;
    pthread_rwlock_t lock;
} PTO2PendingFinalQueue;

/**
 * 优化的调度器状态
 */
#ifdef PTO2_ENABLE_TWO_PHASE_OPT
    typedef struct {
        // === 现有PTO2SchedulerState字段 ===
        PTO2SharedMemoryHandle* sm_handle;
        int32_t last_task_alive;
        int32_t heap_tail;
        int32_t task_window_size;
        int32_t task_window_mask;

        PTO2TaskState* task_state;
        int32_t* fanin_refcount;
        int32_t* fanout_refcount;

        PTO2ReadyQueue ready_queues[4];
        PTO2DepListPool* dep_pool;

        // === 新增字段 ===
        PTO2PendingFinalQueue pending_queues[4];  // 4种worker类型

        // === 性能统计 ===
        int64_t pending_total_count;
        int64_t pending_ready_count;
        int64_t register_path_hits;
        int64_t memory_path_ops;

        // 统计信息
        int64_t tasks_completed;
        int64_t tasks_consumed;
        int64_t total_dispatch_cycles;

        // === 配置 ===
        bool two_phase_enabled;
        int32_t pending_batch_size;

    } PTO2SchedulerStateOptimized;
#endif

// ============================================================================
// 两阶段优化API声明
// ============================================================================

#ifdef PTO2_ENABLE_TWO_PHASE_OPT

/**
 * 阶段1：更新consumer的fanin_refcount（memory域）
 *
 * @return true表示只剩1个依赖，应移到待定队列
 */
bool pto2_phase1_update_consumer_refcount(
    PTO2SchedulerStateOptimized* sched,
    int32_t consumer_id,
    int32_t producer_id);

/**
 * 阶段2：将只剩1个依赖的任务移到待定队列
 */
void pto2_phase2_migrate_to_pending(
    PTO2SchedulerStateOptimized* sched,
    int32_t consumer_id);

/**
 * 阶段3：生产者完成时快速匹配待定队列
 *
 * @param producer_id 完成的生产者任务ID
 */
void pto2_phase3_fast_matching(
    PTO2SchedulerStateOptimized* sched,
    int32_t producer_id,
    PTO2ThreadContext* thread_ctx);

/**
 * 打印两阶段优化性能统计
 */
void pto2_print_two_phase_metrics(
    const PTO2SchedulerStateOptimized* sched);

#endif // PTO2_ENABLE_TWO_PHASE_OPT
```

**集成检查点**:
- [ ] 所有新增API都有 `#ifdef` 保护
- [ ] 函数声明清晰，参数和返回值明确
- [ ] 正确使用 `PTO2SchedulerStateOptimized` 类型
- [ ] 性能统计函数包含在 `#ifdef` 中

### 修改3: pto_scheduler.c

**位置**: `ref_runtime/src/runtime/rt2/runtime/pto_scheduler.c`

**修改内容**: 在文件末尾添加

```c
// ============================================================================
// 两阶段依赖解析优化实现
// ============================================================================

#ifdef PTO2_ENABLE_TWO_PHASE_OPT

#include "pto_scheduler.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ============================================================================
// 阶段1: Memory域依赖计数
// ============================================================================

bool pto2_phase1_update_consumer_refcount(
    PTO2SchedulerStateOptimized* sched,
    int32_t consumer_id,
    int32_t producer_id)
{
    int32_t slot = pto2_task_slot((PTO2SchedulerState*)sched, consumer_id);

    // 使用relaxed内存序，比SEQ_CST快约30%
    int32_t new_count = __atomic_add_fetch_explicit(
        &((PTO2SchedulerState*)sched)->fanin_refcount[slot],
        1,
        __ATOMIC_RELAXED
    );

    // 读取fanin_count
    int32_t total_count = __atomic_load_explicit(
        &((PTO2TaskDescriptorOptimized*)sched)->optimized_tasks[slot].fanin_count,
        __ATOMIC_ACQUIRE
    );

    // 计算剩余依赖
    int32_t remaining = total_count - new_count;

    sched->memory_path_ops++;

    if (remaining > 1) {
        // 仍有多个依赖，继续在memory域
        ((PTO2TaskDescriptorOptimized*)sched)->optimized_tasks[slot].dep_state =
            PTO2_DEP_STATE_RESOLVING;
        return false;
    }

    // 只剩1个依赖了！准备进入阶段2
    ((PTO2TaskDescriptorOptimized*)sched)->optimized_tasks[slot].dep_state =
        PTO2_DEP_STATE_LAST_ONE;
    ((PTO2TaskDescriptorOptimized*)sched)->optimized_tasks[slot].final_producer_id =
        producer_id;
    ((PTO2TaskDescriptorOptimized*)sched)->optimized_tasks[slot].fanin_refcount_fast =
        new_count;

    return true;  // 应该移到待定队列
}

// ============================================================================
// 阶段2: 待定队列管理
// ============================================================================

void pto2_phase2_migrate_to_pending(
    PTO2SchedulerStateOptimized* sched,
    int32_t consumer_id)
{
    int32_t slot = pto2_task_slot((PTO2SchedulerState*)sched, consumer_id);
    PTO2TaskDescriptorOptimized* consumer =
        &((PTO2SchedulerState*)sched)->optimized_tasks[slot];
    PTO2WorkerType worker_type = consumer->worker_type;

    PTO2PendingFinalQueue* pending_q = &sched->pending_queues[worker_type];

    // 使用读写锁，允许多producer并发写入
    pthread_rwlock_wrlock(&pending_q->lock);

    // 检查容量
    if (pending_q->count >= pending_q->capacity) {
        pthread_rwlock_unlock(&pending_q->lock);
        fprintf(stderr, "[ERROR] Pending queue full for worker type %d\n", worker_type);
        return;
    }

    // 入队到循环buffer尾部
    int64_t tail = pending_q->tail;
    pending_q->task_ids[tail & (pending_q->capacity - 1)] = consumer_id;
    pending_q->tail = tail + 1;
    pending_q->count++;

    sched->pending_total_count++;

    pthread_rwlock_unlock(&pending_q->lock);
}

// ============================================================================
// 阶段3: Register域快速匹配
// ============================================================================

void pto2_phase3_fast_matching(
    PTO2SchedulerStateOptimized* sched,
    int32_t producer_id,
    PTO2ThreadContext* thread_ctx)
{
    PTO2WorkerType worker_types[] = {
        PTO2_WORKER_CUBE, PTO2_WORKER_VECTOR,
        PTO2_WORKER_AI_CPU, PTO2_WORKER_ACCELERATOR
    };

    // 遍历所有worker类型的待定队列
    for (int wt = 0; wt < 4; wt++) {
        PTO2PendingFinalQueue* pending_q =
            &((PTO2SchedulerState*)sched)->pending_queues[wt];

        // 快速检查：如果队列为空，跳过
        if (__atomic_load_explicit(&pending_q->count, __ATOMIC_RELAXED) == 0) {
            continue;
        }

        // 批量读取待定队列
        pthread_rwlock_rdlock(&pending_q->lock);

        int32_t task_ids[256];
        int32_t count = 0;

        for (int64_t i = pending_q->head; i != pending_q->tail; i++) {
            int32_t idx = i & (pending_q->capacity - 1);
            task_ids[count++] = pending_q->task_ids[idx];

            if (count >= 256) break;  // 防止溢出
        }

        pthread_rwlock_unlock(&pending_q->lock);

        // 对每个待定任务进行快速标量compare
        for (int i = 0; i < count; i++) {
            int32_t consumer_id = task_ids[i];
            int32_t slot = pto2_task_slot((PTO2SchedulerState*)sched, consumer_id);
            PTO2TaskDescriptorOptimized* consumer =
                &((PTO2SchedulerState*)sched)->optimized_tasks[slot];

            // ✅ 关键路径优化：标量compare，只需5ns！
            if (consumer->dep_state == PTO2_DEP_STATE_LAST_ONE &&
                consumer->final_producer_id == producer_id) {

                sched->register_path_hits++;

                // 尝试转换状态到READY
                PTO2TaskState expected = PTO2_TASK_PENDING;
                if (__atomic_compare_exchange_n(
                        &((PTO2SchedulerState*)sched)->task_state[slot],
                        &expected,
                        PTO2_TASK_READY,
                        __ATOMIC_ACQ_REL,  // ← 只需ACQ_REL，比SEQ_CST快2x！
                        __ATOMIC_ACQUIRE)) {

                    // 成功转换！入队到ready queue
                    pto2_scheduler_enqueue_ready_threadsafe(
                        (PTO2SchedulerState*)sched,
                        consumer_id,
                        worker_types[wt],
                        thread_ctx
                    );

                    sched->pending_ready_count++;
                }
            }
        }
    }
}

// ============================================================================
// 性能统计
// ============================================================================

void pto2_print_two_phase_metrics(
    const PTO2SchedulerStateOptimized* sched)
{
    printf("\n=== Two-Phase Optimization Metrics ===\n");
    printf("Phase 1 (Memory Domain):\n");
    printf("  Operations: %lld\n", sched->memory_path_ops);
    printf("\nPhase 2 (Pending Queue):\n");
    printf("  Total migrations: %lld\n", sched->pending_total_count);
    printf("  Ready migrations: %lld\n", sched->pending_ready_count);
    printf("\nPhase 3 (Register Domain):\n");
    printf("  Register path hits: %lld\n", sched->register_path_hits);
    printf("  Hit rate: %.2f%%\n",
           100.0 * sched->register_path_hits / (sched->tasks_completed + 1));
    printf("\nOverall:\n");
    printf("  Tasks completed: %lld\n", sched->tasks_completed);
    printf("  Throughput: %.2f M tasks/sec\n",
           sched->tasks_completed / 1000000.0);
}

#endif // PTO2_ENABLE_TWO_PHASE_OPT
```

**集成检查点**:
- [ ] 文件添加在末尾，不影响现有代码
- [ ] 所有代码在 `#ifdef` 保护中
- [ ] 使用正确的类型转换（显式cast）
- [ ] 错误处理完善（如队列满）
- [ ] 性能统计正确收集

### 修改4: pto_orchestrator.c

**位置**: `ref_runtime/src/runtime/rt2/runtime/pto_orchestrator.c`

**修改目的**: 确保与新优化方案的兼容性

**修改内容**:

```c
// 在适当位置添加检查

#ifdef PTO2_ENABLE_TWO_PHASE_OPT
    // 如果生产者已经完成，直接更新consumer的fanin_refcount
    // 避免通过fanout链表间接更新
    if (prod_state >= PTO2_TASK_COMPLETED) {
        int32_t cons_slot = pto2_task_slot(sched, consumer_id);
        __atomic_add_fetch_explicit(
            &sched->fanin_refcount[cons_slot],
            1,
            __ATOMIC_RELAXED
        );
        return;
    }
#endif
```

**集成检查点**:
- [ ] 修改最小化，不破坏现有逻辑
- [ ] 仅在优化启用时执行特殊处理
- [ ] 保持向后兼容性

---

## 幻灯片 3: 编译集成

### 修改5: CMakeLists.txt

**位置**: `CMakeLists.txt`（根目录或 ref_runtime/）

**修改内容**:

```cmake
# 在适当位置添加

# ============================================================================
# 两阶段依赖解析优化
# ============================================================================

option(PTO2_ENABLE_TWO_PHASE_OPT
       "Enable two-phase dependency resolution optimization"
       OFF)

if(PTO2_ENABLE_TWO_PHASE_OPT)
    message(STATUS "Two-phase dependency resolution optimization ENABLED")

    target_compile_definitions(pto_runtime2 PRIVATE
        PTO2_ENABLE_TWO_PHASE_OPT
        TWO_PHASE_OPT_VERSION_MAJOR=2
        TWO_PHASE_OPT_VERSION_MINOR=0)

    # 添加优化定义
    target_compile_definitions(pto_runtime2 PRIVATE
        PTO2_TASK_DESCR_OPT_VERSION="${TWO_PHASE_OPT_VERSION_MAJOR}.${TWO_PHASE_OPT_VERSION_MINOR}")

else()
    message(STATUS "Two-phase dependency resolution optimization DISABLED")

    target_compile_definitions(pto_runtime2 PRIVATE
        TWO_PHASE_OPT_VERSION_MAJOR=1
        TWO_PHASE_OPT_VERSION_MINOR=0)

    target_compile_definitions(pto_runtime2 PRIVATE
        PTO2_TASK_DESCR_OPT_VERSION="1.0")
endif()
```

**集成检查点**:
- [ ] `option()` 语法正确
- [ ] `message()` 用于构建时状态提示
- [ ] `target_compile_definitions()` 添加到正确的target
- [ ] version号与代码实现一致

### 编译验证

```bash
# 启用优化编译
cd E:\cccode\pto-isa\ref_runtime
mkdir -p build_two_phase
cd build_two_phase

cmake -DPTO2_ENABLE_TWO_PHASE_OPT ..
make -j4

# 验证版本号
strings libpto_runtime2.so | grep "TWO_PHASE_OPT_VERSION"

# 预期输出
# TWO_PHASE_OPT_VERSION: 2.0
```

---

## 幻灯片 4: 测试集成

### 测试文件结构

```
tests/
├── unit/
│   ├── test_phase1_memory_domain.c      # 阶段1逻辑测试
│   ├── test_phase2_pending_queue.c      # 阶段2队列测试
│   ├── test_phase3_register_domain.c      # 阶段3快速匹配测试
│   └── test_integration.c                # 集成测试
├── performance/
│   ├── benchmark_dependency_resolution.c   # 性能基准测试
│   └── stress_test.cpp                   # 压力测试
└── integration/
    └── test_bgemm_two_phase.c           # 端到端BGEMM测试
```

### 单元测试示例

```c
// tests/unit/test_phase1_memory_domain.c

#include <assert.h>
#include "../ref_runtime/src/runtime/rt2/runtime/pto_scheduler.h"

void test_phase1_remaining_check() {
    PTO2SchedulerStateOptimized sched;
    pto2_scheduler_init_optimized(&sched);

    // 创建1个有3个依赖的consumer
    int32_t consumer = create_task(&sched, 3);
    int32_t remaining_before = 999;

    // 模拟3次依赖完成
    for (int i = 0; i < 2; i++) {
        bool migrated = pto2_phase1_update_consumer_refcount(&sched, consumer, producer);
        if (migrated) {
            // 第3次应该返回true，移到pending
            assert(sched.optimized_tasks[consumer].dep_state == PTO2_DEP_STATE_LAST_ONE);
            remaining_before = 0;
            break;
        }
    }

    // 验证：只有最后1次依赖时才移到pending
    assert(remaining_before == 0);
    printf("✓ Test phase1_remaining_check passed\n");
}

void test_phase3_register_optimization() {
    PTO2SchedulerStateOptimized sched;
    pto2_scheduler_init_optimized(&sched);

    // 创建1个producer，2个只依赖它的consumer
    int32_t producer = create_task(&sched, 0);
    int32_t consumer1 = create_task_with_fanin(&sched, 1, producer);
    int32_t consumer2 = create_task_with_fanin(&sched, 1, producer);

    // 验证两个consumer都移到pending queue
    assert(sched.optimized_tasks[consumer1].dep_state == PTO2_DEP_STATE_LAST_ONE);
    assert(sched.optimized_tasks[consumer2].dep_state == PTO2_DEP_STATE_LAST_ONE);

    // 完成producer，应该快速匹配2个consumer
    pto2_scheduler_on_task_complete(&sched, producer);

    // 验证register path命中
    assert(sched.register_path_hits == 2);
    printf("✓ Test phase3_register_optimization passed\n");
}
```

---

## 幻灯片 5: 部署流程

### 开发环境配置

```bash
# 开发分支策略
git checkout -b feature/two-phase-optim
git branch -U origin/main

# 提交策略
git add -A
git commit -m "feat: 两阶段依赖解析优化

  - 新增PTO2DepResolutionState枚举
  - 扩展PTO2TaskDescriptorOptimized结构
  - 新增PTO2PendingFinalQueue数据结构
  - 实现phase1/2/3核心算法
  - 修改on_task_complete_threadsafe
  - 添加性能统计和监控
  - 添加编译选项-DPTO2_ENABLE_TWO_PHASE_OPT"

# 推送分支（代码审查后）
git push origin feature/two-phase-optim
```

### 灰度发布流程

```
Week 1-2: 开发环境验证
  ├─ 搭建测试环境
  ├─ 运行所有单元测试
  ├─ 性能基准测试
  └─ 10%流量：PTO2_ENABLE_TWO_PHASE_OPT=1 (10%用户)

Week 3-4: 50%流量测试
  ├─ 监控错误率和性能
  ├─ 对比基线性能
  └─ 根据反馈快速迭代

Week 5-6: 100%流量验证
  ├─ 全量性能测试
  ├─ 长期稳定性测试
  └─ 准备生产发布

Week 7-8: 生产发布
  ├─ 移除feature flag
  ├─ 合并到主分支
  ├─ 版本打tag
  └─ 编写发布文档
```

### 监控指标

```yaml
# metrics.yaml（或JSON）

production_targets:
  critical_path_latency_p50: < 150  # ns
  critical_path_latency_p99: < 300  # ns
  register_path_hit_rate: > 80%      # %
  throughput_improvement: > 100%       # vs baseline
  error_rate: < 0.01%                # %
  memory_leak: none                       # 长期测试

rollback_triggers:
  - error_rate > 1%
  - critical_path_latency_p99 > 500
  - throughput_improvement < 50%
```

---

## 幻灯片 6: 成功标准

### 验收标准

**功能完整性**:
- [ ] 所有单元测试通过
- [ ] 端到端BGEMM测试通过
- [ ] 向后兼容性验证（禁用优化时功能正常）
- [ ] 文档完整性

**性能目标**:
- [ ] 关键路径延迟降低 ≥ 50%
- [ ] 整体吞吐量提升 ≥ 100%
- [ ] Register path命中 ≥ 80%
- [ ] 无性能回归（其他指标不降低）

**稳定性要求**:
- [ ] 24小时压力测试无崩溃
- [ ] 10次连续运行结果一致
- [ ] 内存泄漏检测通过

### 发布检查清单

- [ ] 代码审查通过（≥2名reviewer）
- [ ] 性能测试完成（多场景、多配置）
- [ ] 文档完整（设计、API、测试、部署）
- [ ] 监控和告警配置完成
- [ ] 回滚计划明确
- [ ] 用户通知和培训完成

---

**实施指南 v1.0**
**创建日期**: 2025-02-10
**目标受众**: 开发团队、项目经理
**建议演讲时长**: 40-50分钟
