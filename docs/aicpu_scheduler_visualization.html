<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AICPU 调度算法可视化 - PTO-ISA</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 20px;
        }

        header h1 {
            font-size: 28px;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        header p {
            color: #888;
            margin-top: 5px;
            font-size: 14px;
        }

        /* Control Panel */
        .control-panel {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: space-between;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.primary {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
        }

        button.warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        button.success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        input[type="range"] {
            width: 120px;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
        }

        select {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: inherit;
            cursor: pointer;
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .panel-header h3 {
            font-size: 16px;
            color: #00d4ff;
        }

        .panel-header .stats {
            font-size: 12px;
            color: #888;
        }

        /* DAG Canvas */
        #dag-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            overflow: hidden;
        }

        #dag-canvas {
            width: 100%;
            height: 100%;
        }

        /* Worker Grid */
        .worker-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }

        .worker-card {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .worker-card.vector {
            border-color: rgba(0, 212, 255, 0.3);
        }

        .worker-card.cube {
            border-color: rgba(255, 107, 107, 0.3);
        }

        .worker-card.running {
            animation: pulse 1s infinite;
        }

        .worker-card.vector.running {
            border-color: #00d4ff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .worker-card.cube.running {
            border-color: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .worker-name {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .worker-name.vector { color: #00d4ff; }
        .worker-name.cube { color: #ff6b6b; }

        .worker-clock {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
        }

        .worker-task {
            font-size: 12px;
            padding: 4px 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            min-height: 24px;
        }

        .worker-progress {
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .worker-progress-bar {
            height: 100%;
            width: 0%;
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        .worker-card.vector .worker-progress-bar {
            background: linear-gradient(90deg, #00d4ff, #0099cc);
        }

        .worker-card.cube .worker-progress-bar {
            background: linear-gradient(90deg, #ff6b6b, #ee5a5a);
        }

        /* Queue Panels */
        .queue-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .queue-panel {
            flex: 1;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .queue-panel h4 {
            font-size: 14px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .queue-panel.vector h4 { color: #00d4ff; }
        .queue-panel.cube h4 { color: #ff6b6b; }

        .queue-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 40px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .queue-task {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            animation: fadeIn 0.3s ease;
        }

        .queue-task.vector {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.3), rgba(0, 153, 204, 0.3));
            border: 1px solid rgba(0, 212, 255, 0.5);
        }

        .queue-task.cube {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.3), rgba(238, 90, 90, 0.3));
            border: 1px solid rgba(255, 107, 107, 0.5);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Event Log */
        .event-log {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }

        .event-log::-webkit-scrollbar {
            width: 6px;
        }

        .event-log::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        .event-log::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .event-item {
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            gap: 10px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .event-time {
            color: #00d4ff;
            min-width: 60px;
        }

        .event-type {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            text-transform: uppercase;
        }

        .event-type.ready { background: rgba(0, 212, 255, 0.3); color: #00d4ff; }
        .event-type.running { background: rgba(0, 255, 136, 0.3); color: #00ff88; }
        .event-type.completed { background: rgba(255, 193, 7, 0.3); color: #ffc107; }
        .event-type.dispatch { background: rgba(156, 39, 176, 0.3); color: #ce93d8; }

        .event-message {
            color: #bbb;
        }

        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        .legend-color.pending { background: #666; }
        .legend-color.ready { background: #00d4ff; }
        .legend-color.running { background: #00ff88; }
        .legend-color.completed { background: #ffc107; }
        .legend-color.consumed { background: #888; }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            justify-content: space-around;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-top: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #00d4ff;
        }

        .stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }

        /* DAG Task Node Styles (drawn on canvas) */
        .task-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 10px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        /* Worker Section Header */
        .worker-section {
            margin-bottom: 20px;
        }

        .worker-section-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .worker-section-title h4 {
            font-size: 14px;
        }

        .worker-section-title.vector h4 { color: #00d4ff; }
        .worker-section-title.cube h4 { color: #ff6b6b; }

        .worker-count {
            font-size: 11px;
            padding: 2px 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        /* Animation for task completion */
        @keyframes taskComplete {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .task-completing {
            animation: taskComplete 0.5s ease;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .control-panel {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                justify-content: center;
            }

            .queue-container {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>AICPU 调度算法可视化</h1>
            <p>PTO-ISA Project - Ascend A2/A3 NPU Heterogeneous Multi-core Scheduling</p>
        </header>

        <!-- Control Panel -->
        <div class="control-panel">
            <div class="control-group">
                <button id="btn-start" class="primary">
                    <span>▶</span> 开始
                </button>
                <button id="btn-pause" disabled>
                    <span>⏸</span> 暂停
                </button>
                <button id="btn-step" class="success">
                    <span>⏭</span> 单步
                </button>
                <button id="btn-reset" class="warning">
                    <span>↺</span> 重置
                </button>
            </div>

            <div class="control-group">
                <label>速度</label>
                <input type="range" id="speed-slider" min="1" max="10" value="5">
                <span id="speed-value">5x</span>
            </div>

            <div class="control-group">
                <label>任务数</label>
                <select id="task-count">
                    <option value="8">8 任务</option>
                    <option value="16" selected>16 任务</option>
                    <option value="32">32 任务</option>
                    <option value="64">64 任务</option>
                </select>
            </div>

            <div class="control-group">
                <label>DAG模式</label>
                <select id="dag-pattern">
                    <option value="diamond">菱形</option>
                    <option value="chain">链式</option>
                    <option value="parallel">并行</option>
                    <option value="tree">树形</option>
                </select>
            </div>

            <div class="control-group">
                <label>Vector Workers</label>
                <select id="vector-workers">
                    <option value="2">2</option>
                    <option value="4" selected>4</option>
                    <option value="8">8</option>
                </select>
            </div>

            <div class="control-group">
                <label>Cube Workers</label>
                <select id="cube-workers">
                    <option value="1">1</option>
                    <option value="2" selected>2</option>
                    <option value="4">4</option>
                </select>
            </div>
        </div>

        <!-- Main Grid -->
        <div class="main-grid">
            <!-- DAG Visualization -->
            <div class="panel">
                <div class="panel-header">
                    <h3>任务依赖图 (DAG)</h3>
                    <div class="stats" id="dag-stats">Tasks: 0 | Edges: 0</div>
                </div>
                <div id="dag-container">
                    <canvas id="dag-canvas"></canvas>
                </div>
                <div class="task-tooltip" id="task-tooltip"></div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color pending"></div>
                        <span>PENDING</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color ready"></div>
                        <span>READY</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color running"></div>
                        <span>RUNNING</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color completed"></div>
                        <span>COMPLETED</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color consumed"></div>
                        <span>CONSUMED</span>
                    </div>
                </div>
            </div>

            <!-- Workers -->
            <div class="panel">
                <div class="panel-header">
                    <h3>Worker 状态</h3>
                    <div class="stats" id="worker-stats">Cycle: 0</div>
                </div>

                <div class="worker-section">
                    <div class="worker-section-title vector">
                        <h4>AIV Workers (Vector)</h4>
                        <span class="worker-count" id="vector-count">4</span>
                    </div>
                    <div class="worker-grid" id="vector-workers-grid"></div>
                </div>

                <div class="worker-section">
                    <div class="worker-section-title cube">
                        <h4>AIC Workers (Cube)</h4>
                        <span class="worker-count" id="cube-count">2</span>
                    </div>
                    <div class="worker-grid" id="cube-workers-grid"></div>
                </div>

                <div class="stats-bar">
                    <div class="stat-item">
                        <div class="stat-value" id="stat-completed">0</div>
                        <div class="stat-label">已完成</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-running">0</div>
                        <div class="stat-label">运行中</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-ready">0</div>
                        <div class="stat-label">就绪</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-pending">0</div>
                        <div class="stat-label">等待中</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Queues -->
        <div class="queue-container">
            <div class="queue-panel vector">
                <h4>
                    <span>●</span>
                    Vector Queue (AIV)
                    <span id="vector-queue-count">(0)</span>
                </h4>
                <div class="queue-items" id="vector-queue"></div>
            </div>
            <div class="queue-panel cube">
                <h4>
                    <span>●</span>
                    Cube Queue (AIC)
                    <span id="cube-queue-count">(0)</span>
                </h4>
                <div class="queue-items" id="cube-queue"></div>
            </div>
        </div>

        <!-- Event Log -->
        <div class="panel">
            <div class="panel-header">
                <h3>事件日志 / 时间线</h3>
                <button id="btn-clear-log" style="padding: 5px 10px; font-size: 12px;">清除日志</button>
            </div>
            <div class="event-log" id="event-log"></div>
        </div>
    </div>

    <script>
        // ==================== Constants ====================
        const TASK_STATES = {
            PENDING: 'pending',
            READY: 'ready',
            RUNNING: 'running',
            COMPLETED: 'completed',
            CONSUMED: 'consumed'
        };

        const TASK_TYPES = {
            VECTOR: 'vector',
            CUBE: 'cube'
        };

        const STATE_COLORS = {
            pending: '#666666',
            ready: '#00d4ff',
            running: '#00ff88',
            completed: '#ffc107',
            consumed: '#888888'
        };

        // ==================== Task Class ====================
        class Task {
            constructor(id, name, type, cycles = 10) {
                this.id = id;
                this.name = name;
                this.type = type; // 'vector' or 'cube'
                this.state = TASK_STATES.PENDING;
                this.cycles = cycles;
                this.remainingCycles = cycles;
                this.startCycle = 0;
                this.endCycle = 0;

                // Dependency tracking
                this.faninCount = 0;
                this.faninRefcount = 0;
                this.producers = [];
                this.consumers = [];

                // Position for DAG visualization
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;

                // Animation
                this.pulsePhase = Math.random() * Math.PI * 2;
            }

            isReady() {
                return this.faninRefcount >= this.faninCount;
            }

            addProducer(task) {
                this.producers.push(task);
                this.faninCount++;
            }

            addConsumer(task) {
                this.consumers.push(task);
            }
        }

        // ==================== Worker Class ====================
        class Worker {
            constructor(id, type) {
                this.id = id;
                this.type = type;
                this.currentClock = 0;
                this.currentTask = null;
                this.state = 'idle';
                this.taskProgress = 0;
            }

            assignTask(task, currentCycle) {
                this.currentTask = task;
                this.state = 'busy';
                this.taskProgress = 0;
                task.startCycle = currentCycle;
            }

            step() {
                if (this.currentTask) {
                    this.currentTask.remainingCycles--;
                    this.taskProgress = (this.currentTask.cycles - this.currentTask.remainingCycles) / this.currentTask.cycles;

                    if (this.currentTask.remainingCycles <= 0) {
                        const completedTask = this.currentTask;
                        this.currentClock += completedTask.cycles;
                        this.currentTask = null;
                        this.state = 'idle';
                        this.taskProgress = 0;
                        return completedTask;
                    }
                }
                return null;
            }
        }

        // ==================== Ready Queue Class ====================
        class ReadyQueue {
            constructor(type) {
                this.tasks = [];
                this.type = type;
            }

            push(task) {
                this.tasks.push(task);
            }

            pop() {
                return this.tasks.shift();
            }

            peek() {
                return this.tasks[0];
            }

            isEmpty() {
                return this.tasks.length === 0;
            }

            remove(task) {
                const index = this.tasks.indexOf(task);
                if (index > -1) {
                    this.tasks.splice(index, 1);
                }
            }
        }

        // ==================== Scheduler Class ====================
        class Scheduler {
            constructor() {
                this.tasks = [];
                this.vectorWorkers = [];
                this.cubeWorkers = [];
                this.vectorQueue = new ReadyQueue('vector');
                this.cubeQueue = new ReadyQueue('cube');
                this.currentCycle = 0;
                this.isRunning = false;
                this.speed = 5;
                this.eventCallbacks = [];
            }

            setWorkers(vectorCount, cubeCount) {
                this.vectorWorkers = [];
                this.cubeWorkers = [];

                for (let i = 0; i < vectorCount; i++) {
                    this.vectorWorkers.push(new Worker(`V${i}`, TASK_TYPES.VECTOR));
                }

                for (let i = 0; i < cubeCount; i++) {
                    this.cubeWorkers.push(new Worker(`C${i}`, TASK_TYPES.CUBE));
                }
            }

            setTasks(tasks) {
                this.tasks = tasks;
                this.checkInitialReady();
            }

            checkInitialReady() {
                for (let task of this.tasks) {
                    if (task.faninCount === 0) {
                        task.state = TASK_STATES.READY;
                        this.routeTask(task);
                    }
                }
            }

            routeTask(task) {
                if (task.type === TASK_TYPES.CUBE) {
                    this.cubeQueue.push(task);
                    this.emitEvent('dispatch', `Task ${task.name} → Cube Queue`);
                } else {
                    this.vectorQueue.push(task);
                    this.emitEvent('dispatch', `Task ${task.name} → Vector Queue`);
                }
            }

            selectWorker(queue, workers) {
                let minClock = Infinity;
                let selected = null;

                for (let worker of workers) {
                    if (worker.state === 'idle' && worker.currentClock < minClock) {
                        minClock = worker.currentClock;
                        selected = worker;
                    }
                }
                return selected;
            }

            dispatchTasks() {
                // Dispatch to Vector workers
                while (!this.vectorQueue.isEmpty()) {
                    const worker = this.selectWorker(this.vectorQueue, this.vectorWorkers);
                    if (!worker) break;

                    const task = this.vectorQueue.pop();
                    worker.assignTask(task, this.currentCycle);
                    task.state = TASK_STATES.RUNNING;
                    this.emitEvent('running', `Worker ${worker.id} takes Task ${task.name}`);
                }

                // Dispatch to Cube workers
                while (!this.cubeQueue.isEmpty()) {
                    const worker = this.selectWorker(this.cubeQueue, this.cubeWorkers);
                    if (!worker) break;

                    const task = this.cubeQueue.pop();
                    worker.assignTask(task, this.currentCycle);
                    task.state = TASK_STATES.RUNNING;
                    this.emitEvent('running', `Worker ${worker.id} takes Task ${task.name}`);
                }
            }

            completeTask(task) {
                task.state = TASK_STATES.COMPLETED;
                task.endCycle = this.currentCycle;
                this.emitEvent('completed', `Task ${task.name} completed (cycles: ${task.cycles})`);

                // Update consumers
                let allConsumed = true;
                for (let consumer of task.consumers) {
                    consumer.faninRefcount++;

                    if (consumer.faninRefcount >= consumer.faninCount && consumer.state === TASK_STATES.PENDING) {
                        consumer.state = TASK_STATES.READY;
                        this.routeTask(consumer);
                        this.emitEvent('ready', `Task ${consumer.name} → READY (fanin satisfied)`);
                    }
                }
            }

            step() {
                this.currentCycle++;
                let progress = false;

                // Step all Vector workers
                for (let worker of this.vectorWorkers) {
                    if (worker.state === 'busy') {
                        const completed = worker.step();
                        if (completed) {
                            this.completeTask(completed);
                        }
                        progress = true;
                    }
                }

                // Step all Cube workers
                for (let worker of this.cubeWorkers) {
                    if (worker.state === 'busy') {
                        const completed = worker.step();
                        if (completed) {
                            this.completeTask(completed);
                        }
                        progress = true;
                    }
                }

                // Dispatch new tasks
                this.dispatchTasks();

                return this.hasWork();
            }

            hasWork() {
                // Check if there are any pending or running tasks
                for (let task of this.tasks) {
                    if (task.state !== TASK_STATES.COMPLETED &&
                        task.state !== TASK_STATES.CONSUMED) {
                        return true;
                    }
                }

                // Check if any workers are busy
                for (let worker of this.vectorWorkers) {
                    if (worker.state === 'busy') return true;
                }
                for (let worker of this.cubeWorkers) {
                    if (worker.state === 'busy') return true;
                }

                // Check if queues have tasks
                if (!this.vectorQueue.isEmpty() || !this.cubeQueue.isEmpty()) {
                    return true;
                }

                return false;
            }

            reset() {
                this.currentCycle = 0;
                this.vectorQueue = new ReadyQueue('vector');
                this.cubeQueue = new ReadyQueue('cube');

                for (let worker of this.vectorWorkers) {
                    worker.currentClock = 0;
                    worker.currentTask = null;
                    worker.state = 'idle';
                    worker.taskProgress = 0;
                }

                for (let worker of this.cubeWorkers) {
                    worker.currentClock = 0;
                    worker.currentTask = null;
                    worker.state = 'idle';
                    worker.taskProgress = 0;
                }
            }

            onEvent(callback) {
                this.eventCallbacks.push(callback);
            }

            emitEvent(type, message) {
                const event = {
                    time: this.currentCycle,
                    type: type,
                    message: message
                };
                for (let callback of this.eventCallbacks) {
                    callback(event);
                }
            }

            getStats() {
                const stats = {
                    pending: 0,
                    ready: 0,
                    running: 0,
                    completed: 0,
                    consumed: 0
                };

                for (let task of this.tasks) {
                    stats[task.state]++;
                }

                return stats;
            }
        }

        // ==================== DAG Generator ====================
        class DAGGenerator {
            static generateDiamond(taskCount, cubeRatio = 0.3) {
                const tasks = [];
                const layers = Math.ceil(Math.sqrt(taskCount));
                const tasksPerLayer = Math.ceil(taskCount / layers);

                let taskId = 0;

                // Create layers
                for (let layer = 0; layer < layers && taskId < taskCount; layer++) {
                    const layerTasks = [];
                    const count = Math.min(tasksPerLayer, taskCount - taskId);

                    for (let i = 0; i < count && taskId < taskCount; i++, taskId++) {
                        const isCube = Math.random() < cubeRatio;
                        const task = new Task(
                            taskId,
                            `T${taskId}`,
                            isCube ? TASK_TYPES.CUBE : TASK_TYPES.VECTOR,
                            Math.floor(Math.random() * 15) + 5
                        );
                        task.x = 100 + layer * 120;
                        task.y = 80 + i * 70;
                        tasks.push(task);
                        layerTasks.push(task);
                    }

                    // Connect to previous layer
                    if (layer > 0) {
                        const prevLayerStart = Math.max(0, (layer - 1) * tasksPerLayer);
                        const prevLayerEnd = layer * tasksPerLayer;
                        const prevLayerTasks = tasks.slice(prevLayerStart, prevLayerEnd);

                        for (let task of layerTasks) {
                            // Connect to random tasks from previous layer
                            const numProducers = Math.min(
                                Math.floor(Math.random() * 2) + 1,
                                prevLayerTasks.length
                            );

                            const shuffled = [...prevLayerTasks].sort(() => Math.random() - 0.5);
                            for (let i = 0; i < numProducers; i++) {
                                const producer = shuffled[i];
                                task.addProducer(producer);
                                producer.addConsumer(task);
                            }
                        }
                    }
                }

                return tasks;
            }

            static generateChain(taskCount, cubeRatio = 0.3) {
                const tasks = [];

                for (let i = 0; i < taskCount; i++) {
                    const isCube = Math.random() < cubeRatio;
                    const task = new Task(
                        i,
                        `T${i}`,
                        isCube ? TASK_TYPES.CUBE : TASK_TYPES.VECTOR,
                        Math.floor(Math.random() * 15) + 5
                    );
                    task.x = 80 + (i % 8) * 100;
                    task.y = 100 + Math.floor(i / 8) * 80;
                    tasks.push(task);

                    if (i > 0) {
                        task.addProducer(tasks[i - 1]);
                        tasks[i - 1].addConsumer(task);
                    }
                }

                return tasks;
            }

            static generateParallel(taskCount, cubeRatio = 0.3) {
                const tasks = [];
                const groups = 4;
                const tasksPerGroup = Math.ceil(taskCount / groups);

                let taskId = 0;

                for (let g = 0; g < groups && taskId < taskCount; g++) {
                    for (let i = 0; i < tasksPerGroup && taskId < taskCount; i++, taskId++) {
                        const isCube = Math.random() < cubeRatio;
                        const task = new Task(
                            taskId,
                            `T${taskId}`,
                            isCube ? TASK_TYPES.CUBE : TASK_TYPES.VECTOR,
                            Math.floor(Math.random() * 15) + 5
                        );
                        task.x = 100 + g * 150;
                        task.y = 80 + i * 60;
                        tasks.push(task);

                        if (i > 0) {
                            const prevInGroup = tasks[tasks.length - 2];
                            task.addProducer(prevInGroup);
                            prevInGroup.addConsumer(task);
                        }
                    }
                }

                return tasks;
            }

            static generateTree(taskCount, cubeRatio = 0.3) {
                const tasks = [];

                for (let i = 0; i < taskCount; i++) {
                    const isCube = Math.random() < cubeRatio;
                    const task = new Task(
                        i,
                        `T${i}`,
                        isCube ? TASK_TYPES.CUBE : TASK_TYPES.VECTOR,
                        Math.floor(Math.random() * 15) + 5
                    );

                    // Calculate position based on binary tree
                    const level = Math.floor(Math.log2(i + 1));
                    const posInLevel = i - (Math.pow(2, level) - 1);
                    const levelWidth = Math.pow(2, level);

                    task.x = 100 + (posInLevel + 0.5) * (600 / levelWidth);
                    task.y = 60 + level * 80;

                    tasks.push(task);

                    // Connect to parent
                    if (i > 0) {
                        const parentIndex = Math.floor((i - 1) / 2);
                        task.addProducer(tasks[parentIndex]);
                        tasks[parentIndex].addConsumer(task);
                    }
                }

                return tasks;
            }
        }

        // ==================== Visualization Renderer ====================
        class DAGRenderer {
            constructor(canvas, container) {
                this.canvas = canvas;
                this.container = container;
                this.ctx = canvas.getContext('2d');
                this.tasks = [];
                this.hoveredTask = null;
                this.animationFrame = 0;

                this.resize();
                window.addEventListener('resize', () => this.resize());

                canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                canvas.addEventListener('mouseleave', () => this.handleMouseLeave());
            }

            resize() {
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                this.width = rect.width;
                this.height = rect.height;
            }

            setTasks(tasks) {
                this.tasks = tasks;
                this.layoutTasks();
            }

            layoutTasks() {
                // Auto-layout tasks based on their dependencies
                const levels = this.calculateLevels();

                let maxLevelWidth = 0;
                for (let tasks of levels.values()) {
                    maxLevelWidth = Math.max(maxLevelWidth, tasks.length);
                }

                const levelWidth = this.width / (levels.size + 1);
                const padding = 60;

                for (let [level, tasks] of levels) {
                    const levelHeight = (this.height - padding * 2) / (tasks.length + 1);

                    tasks.forEach((task, index) => {
                        task.targetX = levelWidth * (level + 1);
                        task.targetY = padding + levelHeight * (index + 1);
                    });
                }
            }

            calculateLevels() {
                const levels = new Map();

                const visit = (task, level) => {
                    if (!levels.has(level)) {
                        levels.set(level, []);
                    }

                    if (!levels.get(level).includes(task)) {
                        levels.get(level).push(task);
                    }

                    for (let consumer of task.consumers) {
                        visit(consumer, level + 1);
                    }
                };

                // Start from root tasks (no producers)
                for (let task of this.tasks) {
                    if (task.producers.length === 0) {
                        visit(task, 0);
                    }
                }

                return levels;
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.hoveredTask = null;

                for (let task of this.tasks) {
                    const dx = x - task.x;
                    const dy = y - task.y;
                    if (dx * dx + dy * dy < 400) { // 20px radius
                        this.hoveredTask = task;
                        break;
                    }
                }

                this.updateTooltip(e, x, y);
            }

            handleMouseLeave() {
                this.hoveredTask = null;
                document.getElementById('task-tooltip').style.display = 'none';
            }

            updateTooltip(e, x, y) {
                const tooltip = document.getElementById('task-tooltip');

                if (this.hoveredTask) {
                    const task = this.hoveredTask;
                    tooltip.innerHTML = `
                        <strong>${task.name}</strong><br>
                        Type: ${task.type.toUpperCase()}<br>
                        State: ${task.state.toUpperCase()}<br>
                        Cycles: ${task.cycles}<br>
                        Fanin: ${task.faninRefcount}/${task.faninCount}
                    `;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (x + 15) + 'px';
                    tooltip.style.top = (y + 15) + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            }

            render() {
                this.animationFrame++;
                const ctx = this.ctx;

                // Clear canvas
                ctx.clearRect(0, 0, this.width, this.height);

                // Smooth position interpolation
                for (let task of this.tasks) {
                    task.x += (task.targetX - task.x) * 0.1;
                    task.y += (task.targetY - task.y) * 0.1;
                }

                // Draw edges
                for (let task of this.tasks) {
                    for (let consumer of task.consumers) {
                        this.drawEdge(task, consumer);
                    }
                }

                // Draw nodes
                for (let task of this.tasks) {
                    this.drawNode(task);
                }
            }

            drawEdge(from, to) {
                const ctx = this.ctx;

                ctx.beginPath();
                ctx.moveTo(from.x, from.y);

                // Bezier curve for smooth edges
                const midX = (from.x + to.x) / 2;
                ctx.bezierCurveTo(midX, from.y, midX, to.y, to.x, to.y);

                // Edge color based on completion
                if (from.state === TASK_STATES.COMPLETED || from.state === TASK_STATES.CONSUMED) {
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.6)';
                    ctx.setLineDash([]);

                    // Animated flow effect
                    const dashOffset = -this.animationFrame * 2;
                    ctx.setLineDash([5, 5]);
                    ctx.lineDashOffset = dashOffset;
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.setLineDash([5, 5]);
                }

                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw arrow
                this.drawArrow(midX, to.y, to.x, to.y, ctx.strokeStyle);
            }

            drawArrow(fromX, fromY, toX, toY, color) {
                const ctx = this.ctx;
                const headLen = 10;
                const angle = Math.atan2(toY - fromY, toX - fromX);

                ctx.save();
                ctx.translate(toX - 20 * Math.cos(angle), toY - 20 * Math.sin(angle));
                ctx.rotate(angle);

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-headLen, -headLen / 2);
                ctx.lineTo(-headLen, headLen / 2);
                ctx.closePath();

                ctx.fillStyle = color;
                ctx.fill();
                ctx.restore();
            }

            drawNode(task) {
                const ctx = this.ctx;
                const x = task.x;
                const y = task.y;
                const radius = 22;

                // Pulse animation for ready tasks
                let scale = 1;
                if (task.state === TASK_STATES.READY) {
                    task.pulsePhase += 0.1;
                    scale = 1 + Math.sin(task.pulsePhase) * 0.1;
                }

                // Glow effect for running tasks
                if (task.state === TASK_STATES.RUNNING) {
                    const gradient = ctx.createRadialGradient(x, y, radius * 0.5, x, y, radius * 2);
                    gradient.addColorStop(0, 'rgba(0, 255, 136, 0.5)');
                    gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Node circle
                ctx.beginPath();
                ctx.arc(x, y, radius * scale, 0, Math.PI * 2);

                // Fill based on state
                const color = STATE_COLORS[task.state];
                const gradient = ctx.createRadialGradient(x - 5, y - 5, 0, x, y, radius);
                gradient.addColorStop(0, this.lightenColor(color, 30));
                gradient.addColorStop(1, color);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Border
                ctx.strokeStyle = task.type === TASK_TYPES.CUBE ? '#ff6b6b' : '#00d4ff';
                ctx.lineWidth = task === this.hoveredTask ? 3 : 2;
                ctx.stroke();

                // Task name
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 11px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(task.name, x, y);

                // Progress indicator for running tasks
                if (task.state === TASK_STATES.RUNNING) {
                    const progress = (task.cycles - task.remainingCycles) / task.cycles;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + 4, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * progress);
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }

            lightenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return '#' + (
                    0x1000000 +
                    (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
                    (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 +
                    (B < 255 ? (B < 1 ? 0 : B) : 255)
                ).toString(16).slice(1);
            }
        }

        // ==================== UI Controller ====================
        class UIController {
            constructor() {
                this.scheduler = new Scheduler();
                this.renderer = null;
                this.animationId = null;
                this.isRunning = false;

                this.initRenderer();
                this.initControls();
                this.initWorkerDisplay();
                this.reset();
            }

            initRenderer() {
                const canvas = document.getElementById('dag-canvas');
                const container = document.getElementById('dag-container');
                this.renderer = new DAGRenderer(canvas, container);
            }

            initControls() {
                document.getElementById('btn-start').addEventListener('click', () => this.start());
                document.getElementById('btn-pause').addEventListener('click', () => this.pause());
                document.getElementById('btn-step').addEventListener('click', () => this.step());
                document.getElementById('btn-reset').addEventListener('click', () => this.reset());
                document.getElementById('btn-clear-log').addEventListener('click', () => this.clearLog());

                document.getElementById('speed-slider').addEventListener('input', (e) => {
                    this.scheduler.speed = parseInt(e.target.value);
                    document.getElementById('speed-value').textContent = e.target.value + 'x';
                });

                document.getElementById('task-count').addEventListener('change', () => this.reset());
                document.getElementById('dag-pattern').addEventListener('change', () => this.reset());
                document.getElementById('vector-workers').addEventListener('change', () => this.reset());
                document.getElementById('cube-workers').addEventListener('change', () => this.reset());

                this.scheduler.onEvent((event) => this.logEvent(event));
            }

            initWorkerDisplay() {
                this.updateWorkerGrid();
            }

            updateWorkerGrid() {
                const vectorGrid = document.getElementById('vector-workers-grid');
                const cubeGrid = document.getElementById('cube-workers-grid');

                vectorGrid.innerHTML = '';
                cubeGrid.innerHTML = '';

                for (let worker of this.scheduler.vectorWorkers) {
                    vectorGrid.appendChild(this.createWorkerCard(worker));
                }

                for (let worker of this.scheduler.cubeWorkers) {
                    cubeGrid.appendChild(this.createWorkerCard(worker));
                }

                document.getElementById('vector-count').textContent = this.scheduler.vectorWorkers.length;
                document.getElementById('cube-count').textContent = this.scheduler.cubeWorkers.length;
            }

            createWorkerCard(worker) {
                const card = document.createElement('div');
                card.className = `worker-card ${worker.type}`;
                card.id = `worker-${worker.id}`;

                card.innerHTML = `
                    <div class="worker-name ${worker.type}">${worker.id}</div>
                    <div class="worker-clock">clk: <span class="clock-value">${worker.currentClock}</span></div>
                    <div class="worker-task">${worker.currentTask ? worker.currentTask.name : 'idle'}</div>
                    <div class="worker-progress">
                        <div class="worker-progress-bar" style="width: ${worker.taskProgress * 100}%"></div>
                    </div>
                `;

                return card;
            }

            updateWorkerCards() {
                for (let worker of [...this.scheduler.vectorWorkers, ...this.scheduler.cubeWorkers]) {
                    const card = document.getElementById(`worker-${worker.id}`);
                    if (card) {
                        card.className = `worker-card ${worker.type} ${worker.state === 'busy' ? 'running' : ''}`;
                        card.querySelector('.clock-value').textContent = worker.currentClock;
                        card.querySelector('.worker-task').textContent = worker.currentTask ? worker.currentTask.name : 'idle';
                        card.querySelector('.worker-progress-bar').style.width = (worker.taskProgress * 100) + '%';
                    }
                }
            }

            updateQueueDisplay() {
                const vectorQueue = document.getElementById('vector-queue');
                const cubeQueue = document.getElementById('cube-queue');

                vectorQueue.innerHTML = '';
                cubeQueue.innerHTML = '';

                for (let task of this.scheduler.vectorQueue.tasks) {
                    const el = document.createElement('div');
                    el.className = 'queue-task vector';
                    el.textContent = task.name;
                    vectorQueue.appendChild(el);
                }

                for (let task of this.scheduler.cubeQueue.tasks) {
                    const el = document.createElement('div');
                    el.className = 'queue-task cube';
                    el.textContent = task.name;
                    cubeQueue.appendChild(el);
                }

                document.getElementById('vector-queue-count').textContent = `(${this.scheduler.vectorQueue.tasks.length})`;
                document.getElementById('cube-queue-count').textContent = `(${this.scheduler.cubeQueue.tasks.length})`;
            }

            updateStats() {
                const stats = this.scheduler.getStats();

                document.getElementById('stat-completed').textContent = stats.completed;
                document.getElementById('stat-running').textContent = stats.running;
                document.getElementById('stat-ready').textContent = stats.ready;
                document.getElementById('stat-pending').textContent = stats.pending;

                document.getElementById('worker-stats').textContent = `Cycle: ${this.scheduler.currentCycle}`;

                // Update DAG stats
                let edgeCount = 0;
                for (let task of this.scheduler.tasks) {
                    edgeCount += task.consumers.length;
                }
                document.getElementById('dag-stats').textContent = `Tasks: ${this.scheduler.tasks.length} | Edges: ${edgeCount}`;
            }

            logEvent(event) {
                const log = document.getElementById('event-log');
                const item = document.createElement('div');
                item.className = 'event-item';

                const typeLabels = {
                    ready: 'READY',
                    running: 'RUN',
                    completed: 'DONE',
                    dispatch: 'DISPATCH'
                };

                item.innerHTML = `
                    <span class="event-time">[${String(event.time).padStart(4, '0')}]</span>
                    <span class="event-type ${event.type}">${typeLabels[event.type] || event.type}</span>
                    <span class="event-message">${event.message}</span>
                `;

                log.insertBefore(item, log.firstChild);

                // Keep only last 100 events
                while (log.children.length > 100) {
                    log.removeChild(log.lastChild);
                }
            }

            clearLog() {
                document.getElementById('event-log').innerHTML = '';
            }

            generateTasks() {
                const count = parseInt(document.getElementById('task-count').value);
                const pattern = document.getElementById('dag-pattern').value;

                let tasks;
                switch (pattern) {
                    case 'chain':
                        tasks = DAGGenerator.generateChain(count);
                        break;
                    case 'parallel':
                        tasks = DAGGenerator.generateParallel(count);
                        break;
                    case 'tree':
                        tasks = DAGGenerator.generateTree(count);
                        break;
                    case 'diamond':
                    default:
                        tasks = DAGGenerator.generateDiamond(count);
                        break;
                }

                return tasks;
            }

            reset() {
                this.pause();

                const vectorCount = parseInt(document.getElementById('vector-workers').value);
                const cubeCount = parseInt(document.getElementById('cube-workers').value);

                this.scheduler.setWorkers(vectorCount, cubeCount);
                const tasks = this.generateTasks();
                this.scheduler.setTasks(tasks);

                this.renderer.setTasks(tasks);
                this.updateWorkerGrid();
                this.updateQueueDisplay();
                this.updateStats();
                this.clearLog();

                this.logEvent({
                    time: 0,
                    type: 'ready',
                    message: `Simulation initialized with ${tasks.length} tasks, ${vectorCount} vector workers, ${cubeCount} cube workers`
                });
            }

            start() {
                if (this.isRunning) return;

                this.isRunning = true;
                document.getElementById('btn-start').disabled = true;
                document.getElementById('btn-pause').disabled = false;
                document.getElementById('btn-step').disabled = true;

                this.runLoop();
            }

            pause() {
                this.isRunning = false;
                document.getElementById('btn-start').disabled = false;
                document.getElementById('btn-pause').disabled = true;
                document.getElementById('btn-step').disabled = false;

                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            step() {
                if (this.isRunning) return;

                const hasMore = this.scheduler.step();
                this.update();
                this.render();

                if (!hasMore) {
                    this.logEvent({
                        time: this.scheduler.currentCycle,
                        type: 'completed',
                        message: 'All tasks completed!'
                    });
                }
            }

            runLoop() {
                if (!this.isRunning) return;

                // Execute multiple steps based on speed
                const stepsPerFrame = this.scheduler.speed;
                for (let i = 0; i < stepsPerFrame; i++) {
                    const hasMore = this.scheduler.step();
                    if (!hasMore) {
                        this.pause();
                        this.logEvent({
                            time: this.scheduler.currentCycle,
                            type: 'completed',
                            message: 'All tasks completed!'
                        });
                        break;
                    }
                }

                this.update();
                this.render();

                this.animationId = requestAnimationFrame(() => this.runLoop());
            }

            update() {
                this.updateWorkerCards();
                this.updateQueueDisplay();
                this.updateStats();
            }

            render() {
                this.renderer.render();
            }
        }

        // ==================== Initialize ====================
        let ui;

        document.addEventListener('DOMContentLoaded', () => {
            ui = new UIController();

            // Animation loop for rendering
            function animate() {
                ui.render();
                requestAnimationFrame(animate);
            }
            animate();
        });
    </script>
</body>
</html>
