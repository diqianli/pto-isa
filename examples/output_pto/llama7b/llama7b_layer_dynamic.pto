// PTO Module: llama7b_layer
// Generated by PTO ISA Compiler
// Functions: tile_add, tile_mul, tile_muls, tile_exp, tile_silu, tile_rsqrt, tile_matmul, tile_rowmax, tile_rowsum, tile_rowexpandsub, tile_rowexpanddiv, tile_rowexpandmul, rmsnorm_tile, softmax_tile, swiglu_tile, linear_tile, rope_tile, attention_score_tile, attention_output_tile, residual_add_tile, llama_layer_dynamic
// Entry: @llama_layer_dynamic

// Function Type: InCore
func @tile_add(%input_a: !pto.memref<gm,...,f32>, %input_b: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<8x8xf32>
  %b = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %a = tload %input_a[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %b = tload %input_b[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = tadd %a, %b : !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_mul(%input_a: !pto.memref<gm,...,f32>, %input_b: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<8x8xf32>
  %b = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %a = tload %input_a[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %b = tload %input_b[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = tmul %a, %b : !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_muls(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Scalar Declarations
  %scale = alloc_scalar : f32
  
  // Instructions
  %a = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = tmuls %a, %scale : !pto.tile<8x8xf32>, f32
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_exp(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = texp %x : !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_silu(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %neg_x = alloc_tile : !pto.tile<8x8xf32>
  %exp_neg_x = alloc_tile : !pto.tile<8x8xf32>
  %one_plus_exp = alloc_tile : !pto.tile<8x8xf32>
  %sigmoid = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %neg_x = tneg %x : !pto.tile<8x8xf32>
  %exp_neg_x = texp %neg_x : !pto.tile<8x8xf32>
  %one_plus_exp = tadds %exp_neg_x, %1.0 : !pto.tile<8x8xf32>, f32
  %sigmoid = trecip %one_plus_exp : !pto.tile<8x8xf32>
  %result = tmul %x, %sigmoid : !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rsqrt(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = trsqrt %x : !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_matmul(%input_a: !pto.memref<gm,...,f32>, %input_b: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<8x8xf32>
  %b = alloc_tile : !pto.tile<8x8xf32>
  %c = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %a = tload %input_a[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %b = tload %input_b[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %c = tmatmul %a, %b : (!pto.tile<8x8xf32>, !pto.tile<8x8xf32>) -> !pto.tile<8x8xf32>
  tstore %c, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowmax(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x1xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = trowmax %x : !pto.tile<8x8xf32> -> !pto.tile<8x1xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowsum(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x1xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = trowsum %x : !pto.tile<8x8xf32> -> !pto.tile<8x1xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowexpandsub(%input_x: !pto.memref<gm,...,f32>, %input_row: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %row_vals = alloc_tile : !pto.tile<8x1xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input_x[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %row_vals = tload %input_row[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x1xf32>
  %result = trowexpandsub %x, %row_vals : !pto.tile<8x8xf32>, !pto.tile<8x1xf32> -> !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowexpanddiv(%input_x: !pto.memref<gm,...,f32>, %input_row: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %row_vals = alloc_tile : !pto.tile<8x1xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input_x[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %row_vals = tload %input_row[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x1xf32>
  %result = trowexpanddiv %x, %row_vals : !pto.tile<8x8xf32>, !pto.tile<8x1xf32> -> !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowexpandmul(%input_x: !pto.memref<gm,...,f32>, %input_row: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %row_vals = alloc_tile : !pto.tile<8x1xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input_x[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %row_vals = tload %input_row[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x1xf32>
  %result = trowexpandmul %x, %row_vals : !pto.tile<8x8xf32>, !pto.tile<8x1xf32> -> !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @rmsnorm_tile(%input: !pto.memref<gm,...,f32>, %weights: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %x_sq = alloc_tile : !pto.tile<8x8xf32>
  %row_sum = alloc_tile : !pto.tile<8x1xf32>
  %row_mean = alloc_tile : !pto.tile<8x1xf32>
  %row_rsqrt = alloc_tile : !pto.tile<8x1xf32>
  %x_norm = alloc_tile : !pto.tile<8x8xf32>
  %gamma = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Scalar Declarations
  %eps = alloc_scalar : f32
  %inv_cols = alloc_scalar : f32
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %gamma = tload %weights[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %x_sq = tmul %x, %x : !pto.tile<8x8xf32>
  %row_sum = trowsum %x_sq : !pto.tile<8x8xf32> -> !pto.tile<8x1xf32>
  LI %inv_cols:f32, 0.125
  %row_mean = tmuls %row_sum, %inv_cols : !pto.tile<8x1xf32>, f32
  LI %eps:f32, 1e-05
  %row_mean = tadds %row_mean, %eps : !pto.tile<8x1xf32>, f32
  %row_rsqrt = trsqrt %row_mean : !pto.tile<8x1xf32>
  %x_norm = trowexpandmul %x, %row_rsqrt : !pto.tile<8x8xf32>, !pto.tile<8x1xf32> -> !pto.tile<8x8xf32>
  %result = tmul %x_norm, %gamma : !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @softmax_tile(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %row_max = alloc_tile : !pto.tile<8x1xf32>
  %x_shifted = alloc_tile : !pto.tile<8x8xf32>
  %exp_x = alloc_tile : !pto.tile<8x8xf32>
  %row_sum = alloc_tile : !pto.tile<8x1xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %row_max = trowmax %x : !pto.tile<8x8xf32> -> !pto.tile<8x1xf32>
  %x_shifted = trowexpandsub %x, %row_max : !pto.tile<8x8xf32>, !pto.tile<8x1xf32> -> !pto.tile<8x8xf32>
  %exp_x = texp %x_shifted : !pto.tile<8x8xf32>
  %row_sum = trowsum %exp_x : !pto.tile<8x8xf32> -> !pto.tile<8x1xf32>
  %result = trowexpanddiv %exp_x, %row_sum : !pto.tile<8x8xf32>, !pto.tile<8x1xf32> -> !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @swiglu_tile(%input_gate: !pto.memref<gm,...,f32>, %input_up: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %gate = alloc_tile : !pto.tile<8x8xf32>
  %up = alloc_tile : !pto.tile<8x8xf32>
  %neg_gate = alloc_tile : !pto.tile<8x8xf32>
  %exp_neg_gate = alloc_tile : !pto.tile<8x8xf32>
  %one_plus_exp = alloc_tile : !pto.tile<8x8xf32>
  %sigmoid_gate = alloc_tile : !pto.tile<8x8xf32>
  %gate_silu = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %gate = tload %input_gate[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %up = tload %input_up[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %neg_gate = tneg %gate : !pto.tile<8x8xf32>
  %exp_neg_gate = texp %neg_gate : !pto.tile<8x8xf32>
  %one_plus_exp = tadds %exp_neg_gate, %1.0 : !pto.tile<8x8xf32>, f32
  %sigmoid_gate = trecip %one_plus_exp : !pto.tile<8x8xf32>
  %gate_silu = tmul %gate, %sigmoid_gate : !pto.tile<8x8xf32>
  %result = tmul %gate_silu, %up : !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @linear_tile(%input: !pto.memref<gm,...,f32>, %weight: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %w = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %w = tload %weight[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = tmatmul %x, %w : (!pto.tile<8x8xf32>, !pto.tile<8x8xf32>) -> !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @rope_tile(%input: !pto.memref<gm,...,f32>, %cos_cache: !pto.memref<gm,...,f32>, %sin_cache: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %cos_pos = alloc_tile : !pto.tile<8x8xf32>
  %sin_pos = alloc_tile : !pto.tile<8x8xf32>
  %x_cos = alloc_tile : !pto.tile<8x8xf32>
  %x_sin = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %cos_pos = tload %cos_cache[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %sin_pos = tload %sin_cache[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %x_cos = tmul %x, %cos_pos : !pto.tile<8x8xf32>
  %x_sin = tmul %x, %sin_pos : !pto.tile<8x8xf32>
  %result = tadd %x_cos, %x_sin : !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @attention_score_tile(%input_q: !pto.memref<gm,...,f32>, %input_kt: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %q = alloc_tile : !pto.tile<8x8xf32>
  %k_t = alloc_tile : !pto.tile<8x8xf32>
  %scores = alloc_tile : !pto.tile<8x8xf32>
  %scaled_scores = alloc_tile : !pto.tile<8x8xf32>
  
  // Scalar Declarations
  %scale = alloc_scalar : f32
  
  // Instructions
  %q = tload %input_q[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %k_t = tload %input_kt[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %scores = tmatmul %q, %k_t : (!pto.tile<8x8xf32>, !pto.tile<8x8xf32>) -> !pto.tile<8x8xf32>
  LI %scale:f32, 0.08838834764831843
  %scaled_scores = tmuls %scores, %scale : !pto.tile<8x8xf32>, f32
  tstore %scaled_scores, %output[0, 0]
  
  return
}

// Function Type: InCore
func @attention_output_tile(%input_weights: !pto.memref<gm,...,f32>, %input_v: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %weights = alloc_tile : !pto.tile<8x8xf32>
  %v = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %weights = tload %input_weights[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %v = tload %input_v[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = tmatmul %weights, %v : (!pto.tile<8x8xf32>, !pto.tile<8x8xf32>) -> !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @residual_add_tile(%input: !pto.memref<gm,...,f32>, %input_residual: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<8x8xf32>
  %residual = alloc_tile : !pto.tile<8x8xf32>
  %result = alloc_tile : !pto.tile<8x8xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %residual = tload %input_residual[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<8x8xf32>
  %result = tadd %x, %residual : !pto.tile<8x8xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: Orchestration
func @llama_layer_dynamic(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>, %attn_norm_weights: !pto.memref<gm,...,f32>, %wq: !pto.memref<gm,...,f32>, %wk: !pto.memref<gm,...,f32>, %wv: !pto.memref<gm,...,f32>, %wo: !pto.memref<gm,...,f32>, %cos_cache: !pto.memref<gm,...,f32>, %sin_cache: !pto.memref<gm,...,f32>, %mlp_norm_weights: !pto.memref<gm,...,f32>, %w_gate: !pto.memref<gm,...,f32>, %w_up: !pto.memref<gm,...,f32>, %w_down: !pto.memref<gm,...,f32>, %temp_attn_out: !pto.memref<gm,...,f32>, %temp_residual1: !pto.memref<gm,...,f32>, %temp_mlp_out: !pto.memref<gm,...,f32>, %temp_norm: !pto.memref<gm,...,f32>, %temp_q: !pto.memref<gm,...,f32>, %temp_k: !pto.memref<gm,...,f32>, %temp_v: !pto.memref<gm,...,f32>, %temp_q_rope: !pto.memref<gm,...,f32>, %temp_k_rope: !pto.memref<gm,...,f32>, %temp_scores: !pto.memref<gm,...,f32>, %temp_attn_weights: !pto.memref<gm,...,f32>, %temp_gate: !pto.memref<gm,...,f32>, %temp_up: !pto.memref<gm,...,f32>, %temp_swiglu: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  
  // Scalar Declarations
  %seq_len = alloc_scalar : i32
  %tile_rows = alloc_scalar : i32
  %num_full_tiles = alloc_scalar : i32
  %tail_rows = alloc_scalar : i32
  %has_tail = alloc_scalar : u1
  %zero = alloc_scalar : i32
  
  // Instructions
  LI %tile_rows:i32, 8
  LI %zero:i32, 0
  FOR %tile_idx:idx, 0:idx, %num_full_tiles:idx, 1:idx
    CALL @rmsnorm_tile(%input -> %input, %weights -> %attn_norm_weights, %output -> %temp_norm)
    CALL @linear_tile(%input -> %temp_norm, %weight -> %wq, %output -> %temp_q)
    CALL @linear_tile(%input -> %temp_norm, %weight -> %wk, %output -> %temp_k)
    CALL @linear_tile(%input -> %temp_norm, %weight -> %wv, %output -> %temp_v)
    CALL @rope_tile(%input -> %temp_q, %cos_cache -> %cos_cache, %sin_cache -> %sin_cache, %output -> %temp_q_rope)
    CALL @rope_tile(%input -> %temp_k, %cos_cache -> %cos_cache, %sin_cache -> %sin_cache, %output -> %temp_k_rope)
    CALL @attention_score_tile(%input_q -> %temp_q_rope, %input_kt -> %temp_k_rope, %output -> %temp_scores)
    CALL @softmax_tile(%input -> %temp_scores, %output -> %temp_attn_weights)
    CALL @attention_output_tile(%input_weights -> %temp_attn_weights, %input_v -> %temp_v, %output -> %temp_attn_out)
    CALL @linear_tile(%input -> %temp_attn_out, %weight -> %wo, %output -> %temp_attn_out)
    CALL @residual_add_tile(%input -> %temp_attn_out, %input_residual -> %input, %output -> %temp_residual1)
    CALL @rmsnorm_tile(%input -> %temp_residual1, %weights -> %mlp_norm_weights, %output -> %temp_norm)
    CALL @linear_tile(%input -> %temp_norm, %weight -> %w_gate, %output -> %temp_gate)
    CALL @linear_tile(%input -> %temp_norm, %weight -> %w_up, %output -> %temp_up)
    CALL @swiglu_tile(%input_gate -> %temp_gate, %input_up -> %temp_up, %output -> %temp_swiglu)
    CALL @linear_tile(%input -> %temp_swiglu, %weight -> %w_down, %output -> %temp_mlp_out)
    CALL @residual_add_tile(%input -> %temp_mlp_out, %input_residual -> %temp_residual1, %output -> %output)
  ENDFOR
  CMP %has_tail:u1, %tail_rows:i32, %zero:i32, GT
  IF %has_tail:u1
    CALL @rmsnorm_tile(%input -> %input, %weights -> %attn_norm_weights, %output -> %temp_norm)
    CALL @linear_tile(%input -> %temp_norm, %weight -> %wq, %output -> %temp_q)
    CALL @linear_tile(%input -> %temp_norm, %weight -> %wk, %output -> %temp_k)
    CALL @linear_tile(%input -> %temp_norm, %weight -> %wv, %output -> %temp_v)
    CALL @rope_tile(%input -> %temp_q, %cos_cache -> %cos_cache, %sin_cache -> %sin_cache, %output -> %temp_q_rope)
    CALL @rope_tile(%input -> %temp_k, %cos_cache -> %cos_cache, %sin_cache -> %sin_cache, %output -> %temp_k_rope)
    CALL @attention_score_tile(%input_q -> %temp_q_rope, %input_kt -> %temp_k_rope, %output -> %temp_scores)
    CALL @softmax_tile(%input -> %temp_scores, %output -> %temp_attn_weights)
    CALL @attention_output_tile(%input_weights -> %temp_attn_weights, %input_v -> %temp_v, %output -> %temp_attn_out)
    CALL @linear_tile(%input -> %temp_attn_out, %weight -> %wo, %output -> %temp_attn_out)
    CALL @residual_add_tile(%input -> %temp_attn_out, %input_residual -> %input, %output -> %temp_residual1)
    CALL @rmsnorm_tile(%input -> %temp_residual1, %weights -> %mlp_norm_weights, %output -> %temp_norm)
    CALL @linear_tile(%input -> %temp_norm, %weight -> %w_gate, %output -> %temp_gate)
    CALL @linear_tile(%input -> %temp_norm, %weight -> %w_up, %output -> %temp_up)
    CALL @swiglu_tile(%input_gate -> %temp_gate, %input_up -> %temp_up, %output -> %temp_swiglu)
    CALL @linear_tile(%input -> %temp_swiglu, %weight -> %w_down, %output -> %temp_mlp_out)
    CALL @residual_add_tile(%input -> %temp_mlp_out, %input_residual -> %temp_residual1, %output -> %output)
  ENDIF
  
  return
}
